/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package test;

import java.util.HashMap;
import java.util.Map;

import discord4j.core.DiscordClient;
import discord4j.core.GatewayDiscordClient;
import discord4j.core.event.domain.message.MessageCreateEvent;
import discord4j.core.object.entity.Message;
import discord4j.core.object.entity.channel.MessageChannel;

public class App {
	
	private static final Map<String, Command> commands = new HashMap<>();

	static {
	    commands.put("ping", event -> event.getMessage()
	        .getChannel().block()
	        .createMessage("Pong!").block());
	}
	
//	static {
//	    commands.put("ping", event -> event.getMessage().getChannel()
//	        .flatMap(channel -> channel.createMessage("Pong!"))
//	        .then());
//	}

		

    public static void main(String[] args){
    	
    	// Creates AudioPlayer instances and translates URLs to AudioTrack instances
    	final AudioPlayerManager playerManager = new DefaultAudioPlayerManager();

    	// This is an optimization strategy that Discord4J can utilize.
    	// It is not important to understand
    	playerManager.getConfiguration()
    	    .setFrameBufferFactory(NonAllocatingAudioFrameBuffer::new);

    	// Allow playerManager to parse remote sources like YouTube links
    	AudioSourceManagers.registerRemoteSources(playerManager);

    	// Create an AudioPlayer so Discord4J can receive audio data
    	final AudioPlayer player = playerManager.createPlayer();

    	// We will be creating LavaPlayerAudioProvider in the next step
    	AudioProvider provider = new LavaPlayerAudioProvider(player);
  	
	    final String token = "ODg5MDk2MzMwNzM4Mjk4ODgx.YUcRew.NIzaBtL72qrFGyNd2X22L5QD1iA";
	    final DiscordClient client = DiscordClient.create(token);
	    final GatewayDiscordClient gateway = client.login().block();

	    gateway.getEventDispatcher().on(MessageCreateEvent.class)
	    // subscribe is like block, in that it will *request* for action
	    // to be done, but instead of blocking the thread, waiting for it
	    // to finish, it will just execute the results asynchronously.
	    .subscribe(event -> {
	        // 3.1 Message.getContent() is a String
	        final String content = event.getMessage().getContent();

	        for (final Map.Entry<String, Command> entry : commands.entrySet()) {
	            // We will be using ! as our "prefix" to any command in the system.
	            if (content.startsWith('!' + entry.getKey())) {
	                entry.getValue().execute(event);
	                break;
	            }
	        }
	    });
	    
//	    
	    
//	    gateway.on(MessageCreateEvent.class).subscribe(event -> {
//	      final Message message = event.getMessage();
//	      
//	      if ("!안녕".equals(message.getContent())) {
//	        final MessageChannel channel = message.getChannel().block();
//	        channel.createMessage("안녕").block();
//	        // 크롤링 코드 삽입.
//	        // 음악재생 코드 삽입.
//	        // 접두사 걸러내는 법 연구.
//	        // 
//	      }
//	      
//	      if ("!재생".equals(message.getContent())) {
//	    	  final MessageChannel channel = message.getChannel().block();
//		        channel.createMessage("니가 찾아 들어").block();
//		      }
//	    });
//
//	    gateway.onDisconnect().block();

    }
    public String getGreeting() {
        return "Hello World!";
    }
}




